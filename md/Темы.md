Java — Основные операторы в языке: 

- арифметические операторы; - описано но не очень
- инкремента и декремента – описано не очень
- операторы сравнения; - описаны, но не очень
- логические операторы; - описано, но не очень
- операторы присваивания; - описано, но не очень
- приоритет операторов в Java; - нет инфы в курсе



Итого бэкап с драйва
============
Операции присваивания.
Операция присваивания обозначается одиночным знаком равенства ”=”. В Java она выполняет те же функции, что и в других языках программирования. Ниже приведена общая форма записи этой операции:

переменная = выражение

Пример:
int a;      // переменная "a" типа int
a = 1;      // переменной "a" присвоено значение равное 1


Переменная и выражение должны иметь совместимые типы. 

int a = 2.01        // будет ошибка, так как 2.01 формат записи типа double
double d = 2.01     // правильно
int a = 2           // правильно


У операции присваивания имеется одна интересная особенность, о которой вам будет полезно знать: возможность создания цепочки операций присваивания. Рассмотрим, например, следующий фрагмент кода.

int х, у, z;

х = у = z = 100;        // присвоить значение 100 переменным х, у и z

В приведенном выше фрагменте кода одно и то же значение 100 задается для переменных х, у и z с помощью единственного оператора присваивания, в котором значение левого операнда каждой из операций присваивания всякий раз устанавливается равным значению правого операнда. Таким образом, значение 100 присваивается сначала переменной z, затем переменной у и, наконец, переменной х. Такой способ присваивания по цепочке удобен для задания общего значения целой группе переменных.

Существуют более продвинутые операторы сравнения:

“+=” Оператор присваивания «Добавления», он присваивает левому операнду значения правого:
int a = 1;
a += 2;     // a равно 3

“-=” Оператор присваивания «Вычитания», он вычитает из правого операнда левый операнд:
int a = 1;
a -= 2;     // a равно -1

“*=” Оператор присваивания «Умножение», он умножает правый операнд на левый операнд:
int a = 3;
a *= 2;     // a равно 6

“/=” Оператор присваивания «Деление», он делит левый операнд на правый операнд:
int a = 6;
a /= 2;     // a равно 3

“%=” Оператор присваивания «Модуль», он принимает модуль, с помощью двух операндов и присваивает его результат левому операнду:
int a = 3;
a %= 2;      // a равно 1



Арифметические операции.
Операторы +, -, * и / имеют в Java тот же смысл, что и в любом другом языке программирования в частности и в математике вообще, т.е. выполняют обычные арифметические действия. Их можно применять к любым числовым данным встроенных типов, а также к объектам типа char.

int a = 6;
int b = 2;
int r1 = a + b;     // Получится 8
int r2 = 3 + b;     // Получится 5
int r3 = a - b;     // Получится 4
int r4 = a * b;     // Получится 12
int r5 = a / b;     // Получится 3

Несмотря на то что арифметические операции общеизвестны, у них имеются некоторые особенности, требующие специального пояснения. Во-первых, если операция / применяется к целым числам, остаток от деления отбрасывается. Например:

 int a = 10 / 3;        // Получится 3
         
Для получения остатка от деления используется операция деления по модулю %. В Java она выполняется так же, как и в других языках программирования. Например:

 int a = 10 % 3;        // Получится 1

Операция % применима не только к целым числам, но и к числам с плавающей точкой. Следовательно, в результате вычисления выражения 10.0 % 3.0 также будет получено значение 1. Ниже приведен пример программы, демонстрирующий использование операции %.

Пример использования операции:

int iresult = 10 / 3;           // результат 3
int irem = 10 % 3;              // результат 1
double dresult = 10.0 / 3.0;    // результат 3.3333333333333335
double drem = 10.0 % 3.0;       // результат 1.0

Как видите, операция % дает остаток от деления как целых чисел, так и чисел с плавающей точкой.


Инкремент и Декремент
Операция инкремента добавляет к своему операнду единицу.
х++;        // x = x + 1 
Операция х = х + 1; дает тот же результат, что и операция х++;

Операция декремента вычитает единицу из операнда. 
 x--;        // x = x - 1
Операция x-- дает тот же результат, что и операция х = х - 1;

Операции инкремента и декремента могут записываться в одной из двух форм: префиксной (знак операции предшествует операнду) и постфиксной (знак операции следует за операндом). Например, оператор

х = х + 1; можно записать так: 

++х; // префиксная форма

или так:

х++; // постфиксная форма


В приведенных выше примерах результат не зависит от того, какая из форм применена. Но при вычислении более сложных выражений применение этих форм будет давать различные результаты. Общее правило таково: префиксной форме записи операций инкремента и декремента соответствует изменение значения операнда до его использования в соответствующем выражении, а постфиксной - после его использования. Рассмотрим конкретный пример.


х = 10;

у= ++х;

 

В результате выполнения соответствующих действий значение переменной у будет равно 11. Но если изменить код так, как показано ниже, то результат будет другим.

 

х = 10;

у= х++;

 

Теперь значение переменной у равно 10. При этом в обоих случаях значение переменной х будет равно 11. Возможность контролировать момент выполнения операции инкремента или декремента дает немало преимуществ при написании программ.


Приоритет операторов.
Приоритет арифметических операций:
1. Инкремент и Декремент
2. Умножение, деление и деление по модулю
3. Сложение  вычитание

Пример:
int a = 4;
int b = 3;
int c = a + 2 * ++b;  // результат 11

Вначале будет выполняться операция инкремента ++b, которая имеет больший приоритет - она увеличит значение переменной b и возвращает его в качестве результата. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b

Скобки позволяют переопределить порядок вычислений:

int a = 4;
int b = 3;
int c = (a + 2) * ++b;      // результат 24

Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.



Операторы сравнения.
Операторы сравнения:
> — оператор «больше».
>= — оператор «больше или равно».
< — оператор «меньше».
<= — оператор «меньше или равно».
!= — оператор «не равно».
== — оператор эквивалентности (равенства).

Большинство операторов сравнения применимы к числовым значениям. Но последние два оператора могут применяться не только для числовых значений, но и, например, для логических.

Примеры:
boolean a1 = 2 > 1;     // a1 равно true
boolean a2 = 1 > 1;     // a2 равно false
boolean a3 = 1 >= 1;    // a3 равно true
boolean a4 = 2 >= 1;    // a4 равно true
boolean a5 = 1 == 1;    // a5 равно true
boolean a6 = 1 == 2;    // a6 равно false
boolean a7 = 1 != 2;    // a7 равно true
boolean a8 = 1 != 1;    // a8 равно false
boolean a9 = 'r' == 'd';    // a9 равно false
boolean a10 = 'r' == 'r';    // a10 равно true
boolean a11 = 'r' != 'd';    // a11 равно true
boolean a12 = 'r' != 'r';    // a12 равно false

Логические операторы.
Логические операторы работают только с операндами типа boolean. Все логические операторы с двумя операндами объединяют два логических значения, образуя результирующее логическое значения. Не путайте с побитовыми логическими операторами.

Описание операторов:

& - Логическое AND (И)

&& - Сокращённое AND. Если первый операнд false, то второй даже не проверяется

| - Логическое OR (ИЛИ)

|| - Сокращённое OR. Если первый операнд true, то второй даже не проверяется

^ - Логическое XOR (исключающее OR (ИЛИ))

! - Логическое унарное NOT (НЕ)

&= - AND с присваиванием

|= - OR с присваиванием

^= - XOR с присваиванием

?: - Тернарный (троичный) условный оператор


Примеры использования:

boolean example1 = !true;                // результат false
boolean example2 = !false;               // результат true

boolean example3 = false & false;        // результат false
boolean example4 = true & false;         // результат false
boolean example5 = false & true;         // результат false
boolean example6 = true & true;          // результат true

boolean example7 = true | true;          // результат true
boolean example8 = false | true;         // результат true
boolean example9 = true | false;         // результат true
boolean example10 = false | false;       // результат false

boolean example11 = true ^ true;         // результат false
boolean example12 = true ^ false;        // результат true
boolean example13 = false ^ true;        // результат true
boolean example14 = false ^ false;       // результат false



Рассмотрим следующий пример. Допустим, мы ввели правило - кормить или не кормить кота в зависимости от числа пойманных мышек в неделю. Причем число мышей зависит от веса кота. Чем больше кот, тем больше он должен поймать мышей.

int mouse;      // число мышей

int weight;     // вес кота в граммах

mouse = 5;

weight = 4500;
 
if (mouse != 0 & weight / mouse < 1000) System.out.println("Можно кормить кота");


Если запустить программу, то пример будет работать без проблем - пять мышей в неделю вполне достаточно, чтобы побаловать кота вкусным завтраком. Если он поймает четырёх мышей, то начнутся проблемы с питанием кота, но не с программой - она будет работать, просто не будет выводить сообщение о разрешении прокормить дармоеда.

Теперь возьмем крайний случай. Кот обленился и не поймал ни одной мышки. Значение переменной mouse будет равно 0, а в выражении есть оператор деления. А делить на 0 нельзя и наша программа закроется с ошибкой. Казалось бы, мы предусмотрели вариант с 0, но Java вычисляет оба выражения mouse != 0 и weight / mouse < 1000 , несмотря на то, что уже в первом выражении возвращается false.

Перепишем условие следующим образом (добавим всего лишь один символ):

if (mouse != 0 && weight / mouse < 1000) System.out.println("Можно кормить кота");


Теперь программа работает без краха. Как только Java увидела, что первое выражение возвращает false, то второе выражение с делением просто игнорируется.

Сокращенные варианты операторов AND и OR принято использовать в тех ситуациях, когда требуются операторы булевой логики, а их односимвольные родственники используются для побитовых операций.


Тернарный оператор

В языке Java есть также специальный тернарный условный оператор, которым можно заменить определенные типы операторов if-then-else - это оператор ?:

Тернарный оператор использует три операнда. Выражение записывается в следующей форме:

логическое Условие ? выражение1 : выражение2

Если логическое Условие равно true, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же логическое Условие равно false, то вычисляется выражение2, и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.

Рассмотрим пример:

int absval, val;

val = 5;

absval = val < 0 ? 1 : 0;	// результат absval  = 1

val = -5;

absval = val < 0 ? 1: 0;	// результат absval  = 0
